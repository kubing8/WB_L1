package Solutions

import (
	"fmt"
	"sync"
)

// Написать программу, которая конкурентно рассчитает значение квадратов чисел
// взятых из массива (2,4,6,8,10) и выведет их квадраты в stdout.

func Task2() {
	arrayNums := []int{2, 4, 6, 8, 10}       // Инициализация входного массива
	arrayAnsw := make([]int, len(arrayNums)) // Создание места для массива - ответа

	wg := new(sync.WaitGroup) // Создание синхронизирующей группы

	// Проходим по входному массиву и отправляем числа на конкурентный подсчет
	for i, val := range arrayNums {
		wg.Add(1)                        // Добавляем в группу новую горутину
		go sqNum(wg, &arrayAnsw, i, val) // Вызываем подсчет квадрата числа в отдельном потоке
	}

	wg.Wait()                                            // Ждем завершения всех горутин
	fmt.Printf("Исходный массив: %v\n", arrayNums)       // Вывод исходного массива
	fmt.Printf("Результирующий массив: %v\n", arrayAnsw) // Вывод результирующего массива
}

func sqNum(wg *sync.WaitGroup, answer *[]int, ind int, num int) {
	(*answer)[ind] = num * num // Записываем в результируюзий массив квадрат числа
	wg.Done()                  // Убираем закрывающуюся горутину из группы
}

// Второй вариант (более точный в плане задания)
func Task2_2() {
	arrayNums := []int{2, 4, 6, 8, 10} // Инициализация входного массива
	wg := new(sync.WaitGroup)          // Создание синхронизирующей группы
	wg.Add(len(arrayNums))             // Добавляем в группу кол-во горутин

	// Проходим по входному массиву и отправляем числа на конкурентный подсчет
	for _, val := range arrayNums {
		go func(v int) {
			fmt.Println(v * v)
			wg.Done() // Убираем закрывающуюся горутину из группы
		}(val)
	}
	wg.Wait() // Ждем завершения всех горутин
}
